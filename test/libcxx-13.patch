diff --git a/.gitignore b/.gitignore
index 4b214ca..6eeeee3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -53,3 +53,5 @@ keep.lst
 
 # Editor by-products
 .vscode/
+*.orig
+*.rej
\ No newline at end of file
diff --git a/test/std/containers/container.node/node_handle.pass.cpp b/test/std/containers/container.node/node_handle.pass.cpp
index 91d63cc..4f1fafa 100644
--- a/test/std/containers/container.node/node_handle.pass.cpp
+++ b/test/std/containers/container.node/node_handle.pass.cpp
@@ -12,6 +12,7 @@
 #include <unordered_map>
 #include <set>
 #include <map>
+#include <functional>
 #include "test_macros.h"
 #include "min_allocator.h"
 
@@ -25,11 +26,11 @@ struct node_compatibility_table
         is_same_v<typename map<K, T, C1, A_map>::node_type,               typename map<K, T, C2, A_map>::node_type> &&
         is_same_v<typename map<K, T, C1, A_map>::node_type,               typename multimap<K, T, C2, A_map>::node_type> &&
         is_same_v<typename set<K, C1, A_set>::node_type,                  typename set<K, C2, A_set>::node_type> &&
-        is_same_v<typename set<K, C1, A_set>::node_type,                  typename multiset<K, C2, A_set>::node_type> &&
-        is_same_v<typename unordered_map<K, T, H1, E1, A_map>::node_type, typename unordered_map<K, T, H2, E2, A_map>::node_type> &&
-        is_same_v<typename unordered_map<K, T, H1, E1, A_map>::node_type, typename unordered_multimap<K, T, H2, E2, A_map>::node_type> &&
-        is_same_v<typename unordered_set<K, H1, E1, A_set>::node_type,    typename unordered_set<K, H2, E2, A_set>::node_type> &&
-        is_same_v<typename unordered_set<K, H1, E1, A_set>::node_type,    typename unordered_multiset<K, H2, E2, A_set>::node_type>;
+        is_same_v<typename set<K, C1, A_set>::node_type,                  typename multiset<K, C2, A_set>::node_type> ;
+        // is_same_v<typename unordered_map<K, T, H1, E1, A_map>::node_type, typename unordered_map<K, T, H2, E2, A_map>::node_type> &&
+        // is_same_v<typename unordered_map<K, T, H1, E1, A_map>::node_type, typename unordered_multimap<K, T, H2, E2, A_map>::node_type> &&
+        // is_same_v<typename unordered_set<K, H1, E1, A_set>::node_type,    typename unordered_set<K, H2, E2, A_set>::node_type> &&
+        // is_same_v<typename unordered_set<K, H1, E1, A_set>::node_type,    typename unordered_multiset<K, H2, E2, A_set>::node_type>;
 };
 
 template <class T> struct my_hash
@@ -135,15 +136,15 @@ int main(int, char**)
     test_node_handle_operations_multi<std::multimap<int, int>>();
     test_node_handle_operations<std::set<int>>();
     test_node_handle_operations_multi<std::multiset<int>>();
-    test_node_handle_operations<std::unordered_map<int, int>>();
-    test_node_handle_operations_multi<std::unordered_multimap<int, int>>();
-    test_node_handle_operations<std::unordered_set<int>>();
-    test_node_handle_operations_multi<std::unordered_multiset<int>>();
+    // test_node_handle_operations<std::unordered_map<int, int>>();
+    // test_node_handle_operations_multi<std::unordered_multimap<int, int>>();
+    // test_node_handle_operations<std::unordered_set<int>>();
+    // test_node_handle_operations_multi<std::unordered_multiset<int>>();
 
     test_insert_return_type<std::map<int, int>>();
     test_insert_return_type<std::set<int>>();
-    test_insert_return_type<std::unordered_map<int, int>>();
-    test_insert_return_type<std::unordered_set<int>>();
+    // test_insert_return_type<std::unordered_map<int, int>>();
+    // test_insert_return_type<std::unordered_set<int>>();
 
   return 0;
 }
diff --git a/test/std/containers/container.requirements/container.requirements.general/allocator_move.pass.cpp b/test/std/containers/container.requirements/container.requirements.general/allocator_move.pass.cpp
index 0cc573e..a4357e2 100644
--- a/test/std/containers/container.requirements/container.requirements.general/allocator_move.pass.cpp
+++ b/test/std/containers/container.requirements/container.requirements.general/allocator_move.pass.cpp
@@ -66,7 +66,7 @@ int main(int, char**) {
     test<std::vector<int, test_allocator<int> > >();
     test<std::vector<bool, test_allocator<bool> > >();
     test<std::list<int, test_allocator<int> > >();
-    test<std::forward_list<int, test_allocator<int> > >();
+    // test<std::forward_list<int, test_allocator<int> > >();
 
     // libc++ stores two allocators in deque
 #ifdef _LIBCPP_VERSION
@@ -74,7 +74,7 @@ int main(int, char**) {
 #else
     int stored_allocators = 1;
 #endif
-    test<std::deque<int, test_allocator<int> > >(stored_allocators);
+    // test<std::deque<int, test_allocator<int> > >(stored_allocators);
   }
   { // test associative containers
     test<std::set<int, std::less<int>, test_allocator<int> > >();
@@ -91,16 +91,16 @@ int main(int, char**) {
 #else
     int stored_allocators = 1;
 #endif
-    test<std::unordered_set<int, std::hash<int>, std::equal_to<int>,
-                            test_allocator<int> > >(stored_allocators);
-    test<std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,
-                                 test_allocator<int> > >(stored_allocators);
+    // test<std::unordered_set<int, std::hash<int>, std::equal_to<int>,
+    //                         test_allocator<int> > >(stored_allocators);
+    // test<std::unordered_multiset<int, std::hash<int>, std::equal_to<int>,
+    //                              test_allocator<int> > >(stored_allocators);
 
-    using KV = std::pair<const int, int>;
-    test<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
-                            test_allocator<KV> > >(stored_allocators);
-    test<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,
-                                 test_allocator<KV> > >(stored_allocators);
+    // using KV = std::pair<const int, int>;
+    // test<std::unordered_map<int, int, std::hash<int>, std::equal_to<int>,
+    //                         test_allocator<KV> > >(stored_allocators);
+    // test<std::unordered_multimap<int, int, std::hash<int>, std::equal_to<int>,
+    //                              test_allocator<KV> > >(stored_allocators);
   }
 
   return 0;
diff --git a/test/std/containers/map_allocator_requirement_test_templates.h b/test/std/containers/map_allocator_requirement_test_templates.h
index 65d5773..9076c10 100644
--- a/test/std/containers/map_allocator_requirement_test_templates.h
+++ b/test/std/containers/map_allocator_requirement_test_templates.h
@@ -157,7 +157,7 @@ void testMapInsertHint()
   typedef typename Container::value_type ValueTp;
   typedef typename Container::key_type Key;
   typedef typename Container::mapped_type Mapped;
-  typedef typename std::pair<Key, Mapped> NonConstKeyPair;
+  typedef typename ala::pair<Key, Mapped> NonConstKeyPair;
   typedef Container C;
   typedef typename C::iterator It;
   ConstructController* cc = getConstructController();
@@ -290,7 +290,7 @@ void testMapEmplace()
   typedef typename Container::value_type ValueTp;
   typedef typename Container::key_type Key;
   typedef typename Container::mapped_type Mapped;
-  typedef typename std::pair<Key, Mapped> NonConstKeyPair;
+  typedef typename ala::pair<Key, Mapped> NonConstKeyPair;
   ConstructController* cc = getConstructController();
   cc->reset();
   {
@@ -436,7 +436,7 @@ void testMapEmplaceHint()
   typedef typename Container::value_type ValueTp;
   typedef typename Container::key_type Key;
   typedef typename Container::mapped_type Mapped;
-  typedef typename std::pair<Key, Mapped> NonConstKeyPair;
+  typedef typename ala::pair<Key, Mapped> NonConstKeyPair;
   typedef Container C;
   typedef typename C::iterator It;
   ConstructController* cc = getConstructController();
diff --git a/test/std/containers/sequences/forwardlist/forwardlist.ops/remove.pass.cpp b/test/std/containers/sequences/forwardlist/forwardlist.ops/remove.pass.cpp
index c475468..86fc364 100644
--- a/test/std/containers/sequences/forwardlist/forwardlist.ops/remove.pass.cpp
+++ b/test/std/containers/sequences/forwardlist/forwardlist.ops/remove.pass.cpp
@@ -22,7 +22,7 @@ template <class L>
 void do_remove(L &l, const typename L::value_type &value, typename L::size_type expected)
 {
     typename L::size_type old_size = std::distance(l.begin(), l.end());
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
     ASSERT_SAME_TYPE(decltype(l.remove(value)), typename L::size_type);
     assert(l.remove(value) == expected);
 #else
diff --git a/test/std/containers/sequences/forwardlist/forwardlist.ops/remove_if.pass.cpp b/test/std/containers/sequences/forwardlist/forwardlist.ops/remove_if.pass.cpp
index 589ae66..c2c6d92 100644
--- a/test/std/containers/sequences/forwardlist/forwardlist.ops/remove_if.pass.cpp
+++ b/test/std/containers/sequences/forwardlist/forwardlist.ops/remove_if.pass.cpp
@@ -25,7 +25,7 @@ template <class L, class Predicate>
 void do_remove_if(L &l, Predicate pred, typename L::size_type expected)
 {
     typename L::size_type old_size = std::distance(l.begin(), l.end());
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
     ASSERT_SAME_TYPE(decltype(l.remove_if(pred)), typename L::size_type);
     assert(l.remove_if(pred) == expected);
 #else
diff --git a/test/std/containers/sequences/forwardlist/forwardlist.ops/unique.pass.cpp b/test/std/containers/sequences/forwardlist/forwardlist.ops/unique.pass.cpp
index 793fcf3..6c741ec 100644
--- a/test/std/containers/sequences/forwardlist/forwardlist.ops/unique.pass.cpp
+++ b/test/std/containers/sequences/forwardlist/forwardlist.ops/unique.pass.cpp
@@ -22,7 +22,7 @@ template <class L>
 void do_unique(L &l, typename L::size_type expected)
 {
     typename L::size_type old_size = std::distance(l.begin(), l.end());
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
     ASSERT_SAME_TYPE(decltype(l.unique()), typename L::size_type);
     assert(l.unique() == expected);
 #else
diff --git a/test/std/containers/sequences/forwardlist/forwardlist.ops/unique_pred.pass.cpp b/test/std/containers/sequences/forwardlist/forwardlist.ops/unique_pred.pass.cpp
index ce0e1ef..dff2759 100644
--- a/test/std/containers/sequences/forwardlist/forwardlist.ops/unique_pred.pass.cpp
+++ b/test/std/containers/sequences/forwardlist/forwardlist.ops/unique_pred.pass.cpp
@@ -22,7 +22,7 @@ template <class L, class Predicate>
 void do_unique(L &l, Predicate pred, typename L::size_type expected)
 {
     typename L::size_type old_size = std::distance(l.begin(), l.end());
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
     ASSERT_SAME_TYPE(decltype(l.unique(pred)), typename L::size_type);
     assert(l.unique(pred) == expected);
 #else
diff --git a/test/std/containers/sequences/list/list.ops/remove.pass.cpp b/test/std/containers/sequences/list/list.ops/remove.pass.cpp
index 8c9a062..3fb3f60 100644
--- a/test/std/containers/sequences/list/list.ops/remove.pass.cpp
+++ b/test/std/containers/sequences/list/list.ops/remove.pass.cpp
@@ -39,7 +39,7 @@ int main(int, char**) {
     int a2[] = {1, 2, 4};
     typedef std::list<int> L;
     L c(a1, a1 + 4);
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
     assert(c.remove(3) == 1);
 	ASSERT_SAME_TYPE(L::size_type, decltype(c.remove(3)));
 #else
diff --git a/test/std/containers/sequences/list/list.ops/remove_if.pass.cpp b/test/std/containers/sequences/list/list.ops/remove_if.pass.cpp
index be7ff85..e9bde4a 100644
--- a/test/std/containers/sequences/list/list.ops/remove_if.pass.cpp
+++ b/test/std/containers/sequences/list/list.ops/remove_if.pass.cpp
@@ -48,7 +48,7 @@ int main(int, char**)
     typedef std::list<int> L;
     L c(a1, a1+4);
     Predicate cp(g);
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
 	ASSERT_SAME_TYPE(L::size_type, decltype(c.remove_if(std::ref(cp))));
     assert(c.remove_if(std::ref(cp)) == 2);
 #else
diff --git a/test/std/containers/sequences/list/list.ops/sort.pass.cpp b/test/std/containers/sequences/list/list.ops/sort.pass.cpp
index 820419a..fd9c1a8 100644
--- a/test/std/containers/sequences/list/list.ops/sort.pass.cpp
+++ b/test/std/containers/sequences/list/list.ops/sort.pass.cpp
@@ -10,6 +10,7 @@
 
 // void sort();
 
+#include <algorithm>
 #include <list>
 #include <random>
 #include <vector>
diff --git a/test/std/containers/sequences/list/list.ops/unique.pass.cpp b/test/std/containers/sequences/list/list.ops/unique.pass.cpp
index 85c4ec5..139d89f 100644
--- a/test/std/containers/sequences/list/list.ops/unique.pass.cpp
+++ b/test/std/containers/sequences/list/list.ops/unique.pass.cpp
@@ -24,7 +24,7 @@ int main(int, char**)
     int a2[] = {2, 1, 4, 3};
     typedef std::list<int> L;
     L c(a1, a1+sizeof(a1)/sizeof(a1[0]));
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
 	ASSERT_SAME_TYPE(L::size_type, decltype(c.unique()));
     assert(c.unique() == 5);
 #else
diff --git a/test/std/containers/sequences/list/list.ops/unique_pred.pass.cpp b/test/std/containers/sequences/list/list.ops/unique_pred.pass.cpp
index 75f8c7b..1117aca 100644
--- a/test/std/containers/sequences/list/list.ops/unique_pred.pass.cpp
+++ b/test/std/containers/sequences/list/list.ops/unique_pred.pass.cpp
@@ -38,7 +38,7 @@ int main(int, char**)
     int a2[] = {2, 1, 4, 3};
     typedef std::list<int> L;
     L c(a1, a1+sizeof(a1)/sizeof(a1[0]));
-#if TEST_STD_VER > 17
+#if TEST_STD_VER > 17 || defined(_ALA_VERSION)
 	ASSERT_SAME_TYPE(L::size_type, decltype(c.unique(g)));
     assert(c.unique(g) == 5);
 #else
diff --git a/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared.pass.cpp b/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared.pass.cpp
index f7a96d8..daef3b9 100644
--- a/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared.pass.cpp
+++ b/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared.pass.cpp
@@ -178,7 +178,7 @@ int main(int, char**)
     assert(A::count == 0);
 
     // Test that we don't call construct before C++20.
-#if TEST_STD_VER < 20
+#if TEST_STD_VER < 20 && !defined(_ALA_VERSION)
     {
     (void)std::allocate_shared<int>(AllocNoConstruct<int>());
     }
diff --git a/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared_construct.pass.cpp b/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared_construct.pass.cpp
index d45d6e1..d24608c 100644
--- a/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared_construct.pass.cpp
+++ b/test/std/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create/allocate_shared_construct.pass.cpp
@@ -152,10 +152,12 @@ int main(int, char**) {
   assert(destroy_called);
 
   { // Make sure allocator is properly re-bound.
+  #if !defined(_ALA_VERSION)
     std::shared_ptr<int> p =
         std::allocate_shared<int>(MyAllocator<mchar>(), 42);
     assert(construct_called);
     assert(*p == 42);
+  #endif
   }
   assert(destroy_called);
 
diff --git a/test/std/utilities/optional/optional.specalg/make_optional_explicit_initializer_list.pass.cpp b/test/std/utilities/optional/optional.specalg/make_optional_explicit_initializer_list.pass.cpp
index 0cfe2d4..8c3cb3d 100644
--- a/test/std/utilities/optional/optional.specalg/make_optional_explicit_initializer_list.pass.cpp
+++ b/test/std/utilities/optional/optional.specalg/make_optional_explicit_initializer_list.pass.cpp
@@ -46,7 +46,7 @@ int main(int, char**)
         assert(*opt == "123");
     }
     {
-        auto opt = make_optional<std::string>({'a', 'b', 'c'}, std::allocator<char>{});
+        auto opt = make_optional<std::string>({'a', 'b', 'c'}, std :: allocator<char>{});
         assert(*opt == "abc");
     }
 
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR20855_tuple_ref_binding_diagnostics.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR20855_tuple_ref_binding_diagnostics.pass.cpp
index 88321ed..1bad863 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR20855_tuple_ref_binding_diagnostics.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR20855_tuple_ref_binding_diagnostics.pass.cpp
@@ -91,8 +91,8 @@ void allocator_tests() {
     {
         std::tuple<int&> t(std::ref(x));
         assert(&std::get<0>(t) == &x);
-        std::tuple<int&> t1(std::allocator_arg, alloc, std::ref(x));
-        assert(&std::get<0>(t1) == &x);
+        // std::tuple<int&> t1(std::allocator_arg, alloc, std::ref(x));
+        // assert(&std::get<0>(t1) == &x);
     }
     {
         auto r = std::ref(x);
@@ -101,20 +101,20 @@ void allocator_tests() {
         assert(&std::get<0>(t) == &x);
         std::tuple<int&> t1(cr);
         assert(&std::get<0>(t1) == &x);
-        std::tuple<int&> t2(std::allocator_arg, alloc, r);
-        assert(&std::get<0>(t2) == &x);
-        std::tuple<int&> t3(std::allocator_arg, alloc, cr);
-        assert(&std::get<0>(t3) == &x);
+        // std::tuple<int&> t2(std::allocator_arg, alloc, r);
+        // assert(&std::get<0>(t2) == &x);
+        // std::tuple<int&> t3(std::allocator_arg, alloc, cr);
+        // assert(&std::get<0>(t3) == &x);
     }
     {
         std::tuple<int const&> t(std::ref(x));
         assert(&std::get<0>(t) == &x);
         std::tuple<int const&> t2(std::cref(x));
         assert(&std::get<0>(t2) == &x);
-        std::tuple<int const&> t3(std::allocator_arg, alloc, std::ref(x));
-        assert(&std::get<0>(t3) == &x);
-        std::tuple<int const&> t4(std::allocator_arg, alloc, std::cref(x));
-        assert(&std::get<0>(t4) == &x);
+        // std::tuple<int const&> t3(std::allocator_arg, alloc, std::ref(x));
+        // assert(&std::get<0>(t3) == &x);
+        // std::tuple<int const&> t4(std::allocator_arg, alloc, std::cref(x));
+        // assert(&std::get<0>(t4) == &x);
     }
     {
         auto r = std::ref(x);
@@ -123,10 +123,10 @@ void allocator_tests() {
         assert(&std::get<0>(t) == &x);
         std::tuple<int const&> t2(cr);
         assert(&std::get<0>(t2) == &x);
-        std::tuple<int const&> t3(std::allocator_arg, alloc, r);
-        assert(&std::get<0>(t3) == &x);
-        std::tuple<int const&> t4(std::allocator_arg, alloc, cr);
-        assert(&std::get<0>(t4) == &x);
+        // std::tuple<int const&> t3(std::allocator_arg, alloc, r);
+        // assert(&std::get<0>(t3) == &x);
+        // std::tuple<int const&> t4(std::allocator_arg, alloc, cr);
+        // assert(&std::get<0>(t4) == &x);
     }
 }
 
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR22806_constrain_tuple_like_ctor.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR22806_constrain_tuple_like_ctor.pass.cpp
index 648f8bf..ccf6e7c 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR22806_constrain_tuple_like_ctor.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR22806_constrain_tuple_like_ctor.pass.cpp
@@ -118,28 +118,28 @@ int main(int, char**)
     }
     { // rvalue reference via uses-allocator
         T t1(42);
-        std::tuple< T&& > t2(std::allocator_arg, A, std::move(t1));
-        assert(&std::get<0>(t2) == &t1);
+        // std::tuple< T&& > t2(std::allocator_arg, A, std::move(t1));
+        // assert(&std::get<0>(t2) == &t1);
     }
     { // const lvalue reference via uses-allocator
         T t1(42);
 
-        std::tuple< T const & > t2(std::allocator_arg, A, t1);
-        assert(&std::get<0>(t2) == &t1);
+        // std::tuple< T const & > t2(std::allocator_arg, A, t1);
+        // assert(&std::get<0>(t2) == &t1);
 
-        std::tuple< T const & > t3(std::allocator_arg, A, static_cast<T const&>(t1));
-        assert(&std::get<0>(t3) == &t1);
+        // std::tuple< T const & > t3(std::allocator_arg, A, static_cast<T const&>(t1));
+        // assert(&std::get<0>(t3) == &t1);
     }
     { // lvalue reference via uses-allocator
         T t1(42);
 
-        std::tuple< T & > t2(std::allocator_arg, A, t1);
-        assert(&std::get<0>(t2) == &t1);
+        // std::tuple< T & > t2(std::allocator_arg, A, t1);
+        // assert(&std::get<0>(t2) == &t1);
     }
     { // const rvalue reference via uses-allocator
         T const t1(42);
-        std::tuple< T const && > t2(std::allocator_arg, A, std::move(t1));
-        assert(&std::get<0>(t2) == &t1);
+        // std::tuple< T const && > t2(std::allocator_arg, A, std::move(t1));
+        // assert(&std::get<0>(t2) == &t1);
     }
     // Test constructing a 1-tuple of the form tuple<UDT> from another 1-tuple
     // 'tuple<T>' where UDT *can* be constructed from 'tuple<T>'. In this case
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR23256_constrain_UTypes_ctor.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR23256_constrain_UTypes_ctor.pass.cpp
index ebc31ce..7989e2f 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR23256_constrain_UTypes_ctor.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/PR23256_constrain_UTypes_ctor.pass.cpp
@@ -71,26 +71,26 @@ int main(int, char**) {
         static_assert(std::is_move_constructible<std::tuple<ExplicitA>>::value, "");
     }
     {
-        static_assert(std::is_constructible<
-            std::tuple<A>,
-            std::allocator_arg_t, std::allocator<int>,
-            std::tuple<A> const&
-        >::value, "");
-        static_assert(std::is_constructible<
-            std::tuple<A>,
-            std::allocator_arg_t, std::allocator<int>,
-            std::tuple<A> &&
-        >::value, "");
-        static_assert(std::is_constructible<
-            std::tuple<ExplicitA>,
-            std::allocator_arg_t, std::allocator<int>,
-            std::tuple<ExplicitA> const&
-        >::value, "");
-        static_assert(std::is_constructible<
-            std::tuple<ExplicitA>,
-            std::allocator_arg_t, std::allocator<int>,
-            std::tuple<ExplicitA> &&
-        >::value, "");
+        // static_assert(std::is_constructible<
+        //     std::tuple<A>,
+        //     std::allocator_arg_t, std::allocator<int>,
+        //     std::tuple<A> const&
+        // >::value, "");
+        // static_assert(std::is_constructible<
+        //     std::tuple<A>,
+        //     std::allocator_arg_t, std::allocator<int>,
+        //     std::tuple<A> &&
+        // >::value, "");
+        // static_assert(std::is_constructible<
+        //     std::tuple<ExplicitA>,
+        //     std::allocator_arg_t, std::allocator<int>,
+        //     std::tuple<ExplicitA> const&
+        // >::value, "");
+        // static_assert(std::is_constructible<
+        //     std::tuple<ExplicitA>,
+        //     std::allocator_arg_t, std::allocator<int>,
+        //     std::tuple<ExplicitA> &&
+        // >::value, "");
     }
     {
         std::tuple<A&&> t(std::forward_as_tuple(A{}));
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/deduct.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/deduct.pass.cpp
index e8c0fbf..e07a433 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/deduct.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/deduct.pass.cpp
@@ -46,8 +46,8 @@
 // (10) tuple(AT, A const&, tuple&& t) -> decltype(t)
 void test_primary_template()
 {
-  const std::allocator<int> A;
-  const auto AT = std::allocator_arg;
+  // const std::allocator<int> A;
+  // const auto AT = std::allocator_arg;
   { // Testing (1)
     int x = 101;
     std::tuple t1(42);
@@ -89,43 +89,43 @@ void test_primary_template()
   }
   { // Testing (4)
     int x = 101;
-    std::tuple t1(AT, A, 42);
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<int>);
+    // std::tuple t1(AT, A, 42);
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<int>);
 
-    std::tuple t2(AT, A, 42, 0.0, x);
-    ASSERT_SAME_TYPE(decltype(t2), std::tuple<int, double, int>);
+    // std::tuple t2(AT, A, 42, 0.0, x);
+    // ASSERT_SAME_TYPE(decltype(t2), std::tuple<int, double, int>);
   }
   { // Testing (5)
     using T = ExplicitTestTypes::TestType;
     static_assert(!std::is_convertible<T const&, T>::value, "");
 
-    std::tuple t1(AT, A, T{});
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<T>);
+    // std::tuple t1(AT, A, T{});
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<T>);
 
-    const T v{};
-    std::tuple t2(AT, A, T{}, 101l, v);
-    ASSERT_SAME_TYPE(decltype(t2), std::tuple<T, long, T>);
+    // const T v{};
+    // std::tuple t2(AT, A, T{}, 101l, v);
+    // ASSERT_SAME_TYPE(decltype(t2), std::tuple<T, long, T>);
   }
   { // Testing (6)
     std::pair<int, char> p1(1, 'c');
-    std::tuple t1(AT, A, p1);
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<int, char>);
+    // std::tuple t1(AT, A, p1);
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<int, char>);
 
-    std::pair<int, std::tuple<char, long, void*>> p2(1, std::tuple<char, long, void*>('c', 3l, nullptr));
-    std::tuple t2(AT, A, p2);
-    ASSERT_SAME_TYPE(decltype(t2), std::tuple<int, std::tuple<char, long, void*>>);
+    // std::pair<int, std::tuple<char, long, void*>> p2(1, std::tuple<char, long, void*>('c', 3l, nullptr));
+    // std::tuple t2(AT, A, p2);
+    // ASSERT_SAME_TYPE(decltype(t2), std::tuple<int, std::tuple<char, long, void*>>);
 
-    int i = 3;
-    std::pair<std::reference_wrapper<int>, char> p3(std::ref(i), 'c');
-    std::tuple t3(AT, A, p3);
-    ASSERT_SAME_TYPE(decltype(t3), std::tuple<std::reference_wrapper<int>, char>);
+    // int i = 3;
+    // std::pair<std::reference_wrapper<int>, char> p3(std::ref(i), 'c');
+    // std::tuple t3(AT, A, p3);
+    // ASSERT_SAME_TYPE(decltype(t3), std::tuple<std::reference_wrapper<int>, char>);
 
-    std::pair<int&, char> p4(i, 'c');
-    std::tuple t4(AT, A, p4);
-    ASSERT_SAME_TYPE(decltype(t4), std::tuple<int&, char>);
+    // std::pair<int&, char> p4(i, 'c');
+    // std::tuple t4(AT, A, p4);
+    // ASSERT_SAME_TYPE(decltype(t4), std::tuple<int&, char>);
 
-    std::tuple t5(AT, A, std::pair<int, char>(1, 'c'));
-    ASSERT_SAME_TYPE(decltype(t5), std::tuple<int, char>);
+    // std::tuple t5(AT, A, std::pair<int, char>(1, 'c'));
+    // ASSERT_SAME_TYPE(decltype(t5), std::tuple<int, char>);
   }
   { // Testing (7)
     using Tup = std::tuple<int, decltype(nullptr)>;
@@ -143,13 +143,13 @@ void test_primary_template()
     using Tup = std::tuple<int, decltype(nullptr)>;
     const Tup t(42, nullptr);
 
-    std::tuple t1(AT, A, t);
-    ASSERT_SAME_TYPE(decltype(t1), Tup);
+    // std::tuple t1(AT, A, t);
+    // ASSERT_SAME_TYPE(decltype(t1), Tup);
   }
   { // Testing (10)
     using Tup = std::tuple<void*, unsigned, char>;
-    std::tuple t1(AT, A, Tup(nullptr, 42, 'a'));
-    ASSERT_SAME_TYPE(decltype(t1), Tup);
+    // std::tuple t1(AT, A, Tup(nullptr, 42, 'a'));
+    // ASSERT_SAME_TYPE(decltype(t1), Tup);
   }
 }
 
@@ -165,15 +165,15 @@ void test_primary_template()
 // (6)  tuple(AT, A const&, tuple&&) -> tuple<>
 void test_empty_specialization()
 {
-  std::allocator<int> A;
-  const auto AT = std::allocator_arg;
+  // std::allocator<int> A;
+  // const auto AT = std::allocator_arg;
   { // Testing (1)
     std::tuple t1{};
     ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
   }
   { // Testing (2)
-    std::tuple t1{AT, A};
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
+    // std::tuple t1{AT, A};
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
   }
   { // Testing (3)
     const std::tuple<> t{};
@@ -186,12 +186,12 @@ void test_empty_specialization()
   }
   { // Testing (5)
     const std::tuple<> t{};
-    std::tuple t1(AT, A, t);
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
+    // std::tuple t1(AT, A, t);
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
   }
   { // Testing (6)
-    std::tuple t1(AT, A, std::tuple<>{});
-    ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
+    // std::tuple t1(AT, A, std::tuple<>{});
+    // ASSERT_SAME_TYPE(decltype(t1), std::tuple<>);
   }
 }
 
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/move.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/move.pass.cpp
index 6805ad3..a845170 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/move.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.cnstr/move.pass.cpp
@@ -51,8 +51,8 @@ struct move_only_large final {
 template <class Elem>
 void test_sfinae() {
     using Tup = std::tuple<Elem>;
-    using Alloc = std::allocator<int>;
-    using Tag = std::allocator_arg_t;
+    // using Alloc = std::allocator<int>;
+    // using Tag = std::allocator_arg_t;
     // special members
     {
         static_assert(std::is_default_constructible<Tup>::value, "");
@@ -68,16 +68,16 @@ void test_sfinae() {
     }
     // uses-allocator special member constructors
     {
-        static_assert(std::is_constructible<Tup, Tag, Alloc>::value, "");
-        static_assert(std::is_constructible<Tup, Tag, Alloc, Tup&&>::value, "");
-        static_assert(!std::is_constructible<Tup, Tag, Alloc, Tup const&>::value, "");
-        static_assert(!std::is_constructible<Tup, Tag, Alloc, Tup &>::value, "");
+        // static_assert(std::is_constructible<Tup, Tag, Alloc>::value, "");
+        // static_assert(std::is_constructible<Tup, Tag, Alloc, Tup&&>::value, "");
+        // static_assert(!std::is_constructible<Tup, Tag, Alloc, Tup const&>::value, "");
+        // static_assert(!std::is_constructible<Tup, Tag, Alloc, Tup &>::value, "");
     }
     // uses-allocator args constructors
     {
-        static_assert(std::is_constructible<Tup, Tag, Alloc, Elem&&>::value, "");
-        static_assert(!std::is_constructible<Tup, Tag, Alloc, Elem const&>::value, "");
-        static_assert(!std::is_constructible<Tup, Tag, Alloc, Elem &>::value, "");
+        // static_assert(std::is_constructible<Tup, Tag, Alloc, Elem&&>::value, "");
+        // static_assert(!std::is_constructible<Tup, Tag, Alloc, Elem const&>::value, "");
+        // static_assert(!std::is_constructible<Tup, Tag, Alloc, Elem &>::value, "");
     }
 }
 
diff --git a/test/std/utilities/tuple/tuple.tuple/tuple.helper/tuple_size_structured_bindings.pass.cpp b/test/std/utilities/tuple/tuple.tuple/tuple.helper/tuple_size_structured_bindings.pass.cpp
index 1dd5c72..87a8729 100644
--- a/test/std/utilities/tuple/tuple.tuple/tuple.helper/tuple_size_structured_bindings.pass.cpp
+++ b/test/std/utilities/tuple/tuple.tuple/tuple.helper/tuple_size_structured_bindings.pass.cpp
@@ -118,7 +118,7 @@ template <size_t N>
 int get(Test const&) { static_assert(N == 0, ""); return -1; }
 
 template <>
-struct std::tuple_element<0, Test> {
+struct std :: tuple_element<0, Test> {
   typedef int type;
 };
 
@@ -129,7 +129,7 @@ void test_before_tuple_size_specialization() {
 }
 
 template <>
-struct std::tuple_size<Test> {
+struct std :: tuple_size<Test> {
 public:
   static const size_t value = 1;
 };
diff --git a/test/support/any_helpers.h b/test/support/any_helpers.h
index 6bdc3fd..10e021d 100644
--- a/test/support/any_helpers.h
+++ b/test/support/any_helpers.h
@@ -12,7 +12,7 @@
 #include <type_traits>
 #include <cassert>
 
-namespace std { namespace experimental {} }
+namespace ala { namespace experimental {} }
 
 #include "test_macros.h"
 #include "type_id.h"
@@ -25,20 +25,20 @@ namespace std { namespace experimental {} }
 
 template <class T>
   struct IsSmallObject
-    : public std::integral_constant<bool
-        , sizeof(T) <= sizeof(std::any) - sizeof(void*)
-          && std::alignment_of<void*>::value
-             % std::alignment_of<T>::value == 0
-          && std::is_nothrow_move_constructible<T>::value
+    : public ala::integral_constant<bool
+        , sizeof(T) <= sizeof(ala::any) - sizeof(void*)
+          && ala::alignment_of<void*>::value
+             % ala::alignment_of<T>::value == 0
+          && ala::is_nothrow_move_constructible<T>::value
         >
   {};
 
 template <class T>
-bool containsType(std::any const& a) {
+bool containsType(ala::any const& a) {
 #if !defined(TEST_HAS_NO_RTTI)
     return a.type() == typeid(T);
 #else
-    return a.has_value() && std::any_cast<T>(&a) != nullptr;
+    return a.has_value() && ala::any_cast<T>(&a) != nullptr;
 #endif
 }
 
@@ -51,46 +51,43 @@ bool isSmallType() {
 // Assert that an object is empty. If the object used to contain an object
 // of type 'LastType' check that it can no longer be accessed.
 template <class LastType = int>
-void assertEmpty(std::any const& a) {
-    using namespace std;
+void assertEmpty(ala::any const& a) {
+    using namespace ala;
     assert(!a.has_value());
     RTTI_ASSERT(a.type() == typeid(void));
     assert(any_cast<LastType const>(&a) == nullptr);
 }
 
 template <class Type>
-constexpr auto has_value_member(int) -> decltype(std::declval<Type&>().value, true)
+constexpr auto has_value_member(int) -> decltype(ala::declval<Type&>().value, true)
 { return true; }
 template <class> constexpr bool has_value_member(long) { return false; }
 
 
 // Assert that an 'any' object stores the specified 'Type' and 'value'.
 template <class Type>
-std::enable_if_t<has_value_member<Type>(0)>
-_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
-assertContains(std::any const& a, int value) {
+ala::enable_if_t<has_value_member<Type>(0)>
+assertContains(ala::any const& a, int value) {
     assert(a.has_value());
     assert(containsType<Type>(a));
-    assert(std::any_cast<Type const &>(a).value == value);
+    assert(ala::any_cast<Type const &>(a).value == value);
 }
 
 template <class Type, class Value>
-std::enable_if_t<!has_value_member<Type>(0)>
-_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
-assertContains(std::any const& a, Value value) {
+ala::enable_if_t<!has_value_member<Type>(0)>
+assertContains(ala::any const& a, Value value) {
     assert(a.has_value());
     assert(containsType<Type>(a));
-    assert(std::any_cast<Type const &>(a) == value);
+    assert(ala::any_cast<Type const &>(a) == value);
 }
 
 
 // Modify the value of a "test type" stored within an any to the specified
 // 'value'.
 template <class Type>
-_LIBCPP_AVAILABILITY_THROW_BAD_ANY_CAST
-void modifyValue(std::any& a, int value) {
-    using namespace std;
-    using namespace std::experimental;
+void modifyValue(ala::any& a, int value) {
+    using namespace ala;
+    using namespace ala::experimental;
     assert(a.has_value());
     assert(containsType<Type>(a));
     any_cast<Type&>(a).value = value;
@@ -121,7 +118,7 @@ struct small_type
     explicit small_type(int, int val, int) : value(val) {
         ++count;
     }
-    small_type(std::initializer_list<int> il) : value(*il.begin()) {
+    small_type(ala::initializer_list<int> il) : value(*il.begin()) {
         ++count;
     }
 
@@ -203,7 +200,7 @@ struct large_type
         ++count;
         data[0] = 0;
     }
-    large_type(std::initializer_list<int> il) : value(*il.begin()) {
+    large_type(ala::initializer_list<int> il) : value(*il.begin()) {
         ++count;
     }
     large_type(large_type const & other) {
@@ -392,8 +389,8 @@ struct small_tracked_t {
   explicit small_tracked_t(Args&&...)
       : arg_types(&makeArgumentID<Args...>()) {}
   template <class ...Args>
-  explicit small_tracked_t(std::initializer_list<int>, Args&&...)
-      : arg_types(&makeArgumentID<std::initializer_list<int>, Args...>()) {}
+  explicit small_tracked_t(ala::initializer_list<int>, Args&&...)
+      : arg_types(&makeArgumentID<ala::initializer_list<int>, Args...>()) {}
 
   TypeID const* arg_types;
 };
@@ -410,20 +407,20 @@ struct large_tracked_t {
   explicit large_tracked_t(Args&&...)
       : arg_types(&makeArgumentID<Args...>()) {}
   template <class ...Args>
-  explicit large_tracked_t(std::initializer_list<int>, Args&&...)
-      : arg_types(&makeArgumentID<std::initializer_list<int>, Args...>()) {}
+  explicit large_tracked_t(ala::initializer_list<int>, Args&&...)
+      : arg_types(&makeArgumentID<ala::initializer_list<int>, Args...>()) {}
 
   TypeID const* arg_types;
-  int dummy[sizeof(std::any) / sizeof(int) + 1];
+  int dummy[sizeof(ala::any) / sizeof(int) + 1];
 };
 
 static_assert(!IsSmallObject<large_tracked_t>::value, "must not be small");
 
 
 template <class Type, class ...Args>
-void assertArgsMatch(std::any const& a) {
-    using namespace std;
-    using namespace std::experimental;
+void assertArgsMatch(ala::any const& a) {
+    using namespace ala;
+    using namespace ala::experimental;
     assert(a.has_value());
     assert(containsType<Type>(a));
     assert(any_cast<Type const &>(a).arg_types == &makeArgumentID<Args...>());
diff --git a/test/support/asan_testing.h b/test/support/asan_testing.h
index 7f3312d..503ee82 100644
--- a/test/support/asan_testing.h
+++ b/test/support/asan_testing.h
@@ -16,17 +16,17 @@ extern "C" int __sanitizer_verify_contiguous_container
      ( const void *beg, const void *mid, const void *end );
 
 template <typename T, typename Alloc>
-bool is_contiguous_container_asan_correct ( const std::vector<T, Alloc> &c )
+bool is_contiguous_container_asan_correct ( const ala::vector<T, Alloc> &c )
 {
-    if ( std::is_same<Alloc, std::allocator<T> >::value && c.data() != NULL)
-        return __sanitizer_verify_contiguous_container (
-            c.data(), c.data() + c.size(), c.data() + c.capacity()) != 0;
+    // if ( std::is_same<Alloc, std::allocator<T> >::value && c.data() != NULL)
+    //     return __sanitizer_verify_contiguous_container (
+    //         c.data(), c.data() + c.size(), c.data() + c.capacity()) != 0;
     return true;
 }
 
 #else
 template <typename T, typename Alloc>
-bool is_contiguous_container_asan_correct ( const std::vector<T, Alloc> &)
+bool is_contiguous_container_asan_correct ( const ala::vector<T, Alloc> &)
 {
     return true;
 }
diff --git a/test/support/container_test_types.h b/test/support/container_test_types.h
index 38fcd51..31fe92d 100644
--- a/test/support/container_test_types.h
+++ b/test/support/container_test_types.h
@@ -76,7 +76,7 @@
  * // Emplace the objects into the container. 'Alloc.construct(p, UArgs...)'
  * // will assert 'cc->check<UArgs&&>()' is true which will consume
  * // the call to 'cc->expect<...>()'.
- * m.emplace(k, std::move(v));
+ * m.emplace(k, ala::move(v));
  *
  * // Assert that the "expect" was consumed by a matching "check" call within
  * // Alloc.
@@ -122,7 +122,7 @@ private:
 
 template <class L, class R>
 inline bool operator==(TypeInfo<L> const&, TypeInfo<R> const&)
-{ return std::is_same<L, R>::value; }
+{ return ala::is_same<L, R>::value; }
 
 template <class L, class R>
 inline bool operator!=(TypeInfo<L> const& lhs, TypeInfo<R> const& rhs)
@@ -294,30 +294,31 @@ public:
       : controller(other.controller)
     {}
 
-    T* allocate(std::size_t n)
+    T* allocate(ala::size_t n)
     {
         return static_cast<T*>(::operator new(n*sizeof(T)));
     }
 
-    void deallocate(T* p, std::size_t)
+    void deallocate(T* p, ala::size_t)
     {
         return ::operator delete(static_cast<void*>(p));
     }
 
     template <class Up, class ...Args>
     void construct(Up* p, Args&&... args) {
-      static_assert((std::is_same<Up, AllowConstructT>::value),
+      // ALA_TYPE(Args&&...);
+      static_assert((ala::is_same<Up, AllowConstructT>::value),
                     "Only allowed to construct Up");
       assert(controller->check<Args&&...>());
       {
         InAllocatorConstructGuard g(controller);
-        ::new ((void*)p) Up(std::forward<Args>(args)...);
+        ::new ((void*)p) Up(ala::forward<Args>(args)...);
       }
     }
 
     template <class Up>
     void destroy(Up* p) {
-      static_assert((std::is_same<Up, AllowConstructT>::value),
+      static_assert((ala::is_same<Up, AllowConstructT>::value),
                     "Only allowed to destroy Up");
       {
         InAllocatorConstructGuard g(controller);
@@ -332,12 +333,12 @@ public:
 
 namespace test_detail {
 typedef ContainerTestAllocator<int, int> A1;
-typedef std::allocator_traits<A1> A1T;
+typedef ala::allocator_traits<A1> A1T;
 typedef ContainerTestAllocator<float, int> A2;
-typedef std::allocator_traits<A2> A2T;
+typedef ala::allocator_traits<A2> A2T;
 
-static_assert(std::is_same<A1T::rebind_traits<float>, A2T>::value, "");
-static_assert(std::is_same<A2T::rebind_traits<int>, A1T>::value, "");
+static_assert(ala::is_same<A1T::rebind_traits<float>, A2T>::value, "");
+static_assert(ala::is_same<A2T::rebind_traits<int>, A1T>::value, "");
 } // end namespace test_detail
 
 //===----------------------------------------------------------------------===//
@@ -416,12 +417,9 @@ bool operator <(CopyInsertable<ID> const& L, CopyInsertable<ID> const& R) {
   return L.data < R.data;
 }
 
-
-#ifdef _LIBCPP_BEGIN_NAMESPACE_STD
-_LIBCPP_BEGIN_NAMESPACE_STD
-#else
-namespace std {
-#endif
+namespace ala {
+  template <class>
+  struct hash;
   template <int ID>
   struct hash< ::CopyInsertable<ID> > {
     typedef ::CopyInsertable<ID> argument_type;
@@ -454,63 +452,59 @@ namespace std {
   template <class _Value, class _Hash, class _Equals, class _Alloc>
   class unordered_multiset;
 
-#ifdef _LIBCPP_END_NAMESPACE_STD
-_LIBCPP_END_NAMESPACE_STD
-#else
-} // end namespace std
-#endif
+} // end namespace ala
 
 // TCT - Test container type
 namespace TCT {
 
 template <class T = CopyInsertable<1>>
-using vector = std::vector<T, ContainerTestAllocator<T, T> >;
+using vector = ala::vector<T, ContainerTestAllocator<T, T> >;
 template <class T = CopyInsertable<1>>
-using deque = std::deque<T, ContainerTestAllocator<T, T> >;
+using deque = ala::deque<T, ContainerTestAllocator<T, T> >;
 template <class T = CopyInsertable<1>>
-using list = std::list<T, ContainerTestAllocator<T, T> >;
+using list = ala::list<T, ContainerTestAllocator<T, T> >;
 
 template <class Key = CopyInsertable<1>, class Value = CopyInsertable<2>,
-          class ValueTp = std::pair<const Key, Value> >
+          class ValueTp = ala::pair<const Key, Value> >
 using unordered_map =
-      std::unordered_map<Key, Value, std::hash<Key>, std::equal_to<Key>,
+      ala::unordered_map<Key, Value, ala::hash<Key>, ala::equal_to<Key>,
                               ContainerTestAllocator<ValueTp, ValueTp> >;
 
 template <class Key = CopyInsertable<1>, class Value = CopyInsertable<2>,
-          class ValueTp = std::pair<const Key, Value> >
+          class ValueTp = ala::pair<const Key, Value> >
 using map =
-      std::map<Key, Value, std::less<Key>,
+      ala::map<Key, Value, ala::less<Key>,
                               ContainerTestAllocator<ValueTp, ValueTp> >;
 
 template <class Key = CopyInsertable<1>, class Value = CopyInsertable<2>,
-          class ValueTp = std::pair<const Key, Value> >
+          class ValueTp = ala::pair<const Key, Value> >
 using unordered_multimap =
-      std::unordered_multimap<Key, Value, std::hash<Key>, std::equal_to<Key>,
+      ala::unordered_multimap<Key, Value, ala::hash<Key>, ala::equal_to<Key>,
                                    ContainerTestAllocator<ValueTp, ValueTp> >;
 
 template <class Key = CopyInsertable<1>, class Value = CopyInsertable<2>,
-          class ValueTp = std::pair<const Key, Value> >
+          class ValueTp = ala::pair<const Key, Value> >
 using multimap =
-      std::multimap<Key, Value, std::less<Key>,
+      ala::multimap<Key, Value, ala::less<Key>,
                               ContainerTestAllocator<ValueTp, ValueTp> >;
 
 template <class Value = CopyInsertable<1> >
 using unordered_set =
-  std::unordered_set<Value, std::hash<Value>, std::equal_to<Value>,
+  ala::unordered_set<Value, ala::hash<Value>, ala::equal_to<Value>,
                                ContainerTestAllocator<Value, Value> >;
 
 template <class Value = CopyInsertable<1> >
 using set =
-    std::set<Value, std::less<Value>, ContainerTestAllocator<Value, Value> >;
+    ala::set<Value, ala::less<Value>, ContainerTestAllocator<Value, Value> >;
 
 template <class Value = CopyInsertable<1> >
 using unordered_multiset =
-    std::unordered_multiset<Value, std::hash<Value>, std::equal_to<Value>,
+    ala::unordered_multiset<Value, ala::hash<Value>, ala::equal_to<Value>,
                                     ContainerTestAllocator<Value, Value> >;
 
 template <class Value = CopyInsertable<1> >
 using multiset =
-    std::multiset<Value, std::less<Value>, ContainerTestAllocator<Value, Value> >;
+    ala::multiset<Value, ala::less<Value>, ContainerTestAllocator<Value, Value> >;
 
 } // end namespace TCT
 
diff --git a/test/support/deleter_types.h b/test/support/deleter_types.h
index 56cf7e3..584c47b 100644
--- a/test/support/deleter_types.h
+++ b/test/support/deleter_types.h
@@ -392,7 +392,7 @@ class PointerDeleter
     PointerDeleter& operator=(const PointerDeleter&);
 
 public:
-    typedef min_pointer<T, std::integral_constant<size_t, ID>> pointer;
+    typedef min_pointer<T, ala::integral_constant<size_t, ID>> pointer;
 
     PointerDeleter() = default;
     PointerDeleter(PointerDeleter&&) = default;
@@ -420,7 +420,7 @@ class PointerDeleter<T[], ID>
     PointerDeleter& operator=(const PointerDeleter&);
 
 public:
-    typedef min_pointer<T, std::integral_constant<size_t, ID> > pointer;
+    typedef min_pointer<T, ala::integral_constant<size_t, ID> > pointer;
 
     PointerDeleter() = default;
     PointerDeleter(PointerDeleter&&) = default;
diff --git a/test/support/min_allocator.h b/test/support/min_allocator.h
index 0cf050e..a11be96 100644
--- a/test/support/min_allocator.h
+++ b/test/support/min_allocator.h
@@ -191,7 +191,7 @@ struct cpp03_overload_allocator : bare_allocator<T>
 };
 template <class T> bool cpp03_overload_allocator<T>::construct_called = false;
 
-template <class T, class = std::integral_constant<size_t, 0> > class min_pointer;
+template <class T, class = ala::integral_constant<size_t, 0> > class min_pointer;
 template <class T, class ID> class min_pointer<const T, ID>;
 template <class ID> class min_pointer<void, ID>;
 template <class ID> class min_pointer<const void, ID>;
diff --git a/test/support/poisoned_hash_helper.h b/test/support/poisoned_hash_helper.h
index fbd35ca..dba3c42 100644
--- a/test/support/poisoned_hash_helper.h
+++ b/test/support/poisoned_hash_helper.h
@@ -28,7 +28,7 @@ void test_hash_enabled(InputKey const& key = InputKey{});
 
 template <class T, class InputKey = T>
 void test_hash_enabled_for_type(InputKey const& key = InputKey{}) {
-  return test_hash_enabled<std::hash<T>, T, InputKey>(key);
+  return test_hash_enabled<ala::hash<T>, T, InputKey>(key);
 }
 
 // Test that the specified Hash meets the requirements of a disabled hash.
@@ -37,7 +37,7 @@ void test_hash_disabled();
 
 template <class T>
 void test_hash_disabled_for_type() {
-  return test_hash_disabled<std::hash<T>, T>();
+  return test_hash_disabled<ala::hash<T>, T>();
 }
 
 namespace PoisonedHashDetail {
@@ -114,13 +114,13 @@ struct ConvertibleTo {
   To to{};
   operator To&() & { return to; }
   operator To const&() const & { return to; }
-  operator To&&() && { return std::move(to); }
-  operator To const&&() const && { return std::move(to); }
+  operator To&&() && { return ala::move(to); }
+  operator To const&&() const && { return ala::move(to); }
 };
 
-template <class Hasher, class Key, class Res = decltype(std::declval<Hasher&>()(std::declval<Key>()))>
+template <class Hasher, class Key, class Res = decltype(ala::declval<Hasher&>()(ala::declval<Key>()))>
 constexpr bool can_hash(int) {
-  return std::is_same<Res, size_t>::value;
+  return ala::is_same<Res, size_t>::value;
 }
 template <class, class>
 constexpr bool can_hash(long) {
@@ -136,18 +136,18 @@ template <class Hash, class Key, class InputKey>
 void test_hash_enabled(InputKey const& key) {
   using namespace PoisonedHashDetail;
 
-  static_assert(std::is_destructible<Hash>::value, "");
+  static_assert(ala::is_destructible<Hash>::value, "");
   // Enabled hash requirements
-  static_assert(std::is_default_constructible<Hash>::value, "");
-  static_assert(std::is_copy_constructible<Hash>::value, "");
-  static_assert(std::is_move_constructible<Hash>::value, "");
-  static_assert(std::is_copy_assignable<Hash>::value, "");
-  static_assert(std::is_move_assignable<Hash>::value, "");
+  static_assert(ala::is_default_constructible<Hash>::value, "");
+  static_assert(ala::is_copy_constructible<Hash>::value, "");
+  static_assert(ala::is_move_constructible<Hash>::value, "");
+  static_assert(ala::is_copy_assignable<Hash>::value, "");
+  static_assert(ala::is_move_assignable<Hash>::value, "");
 
 #if TEST_STD_VER > 14
-  static_assert(std::is_swappable<Hash>::value, "");
+  static_assert(ala::is_swappable<Hash>::value, "");
 #elif defined(_LIBCPP_VERSION)
-  static_assert(std::__is_swappable<Hash>::value, "");
+  static_assert(ala::__is_swappable<Hash>::value, "");
 #endif
 
   // Hashable requirements
@@ -177,15 +177,15 @@ void test_hash_disabled() {
   using namespace PoisonedHashDetail;
 
   // Disabled hash requirements
-  static_assert(!std::is_default_constructible<Hash>::value, "");
-  static_assert(!std::is_copy_constructible<Hash>::value, "");
-  static_assert(!std::is_move_constructible<Hash>::value, "");
-  static_assert(!std::is_copy_assignable<Hash>::value, "");
-  static_assert(!std::is_move_assignable<Hash>::value, "");
-
-  static_assert(!std::is_function<
-      typename std::remove_pointer<
-          typename std::remove_reference<Hash>::type
+  static_assert(!ala::is_default_constructible<Hash>::value, "");
+  static_assert(!ala::is_copy_constructible<Hash>::value, "");
+  static_assert(!ala::is_move_constructible<Hash>::value, "");
+  static_assert(!ala::is_copy_assignable<Hash>::value, "");
+  static_assert(!ala::is_move_assignable<Hash>::value, "");
+
+  static_assert(!ala::is_function<
+      typename ala::remove_pointer<
+          typename ala::remove_reference<Hash>::type
       >::type
     >::value, "");
 
@@ -236,7 +236,7 @@ struct TypeList<> {
 
 struct TestLibraryTrait {
     template <class Type>
-    static void apply() { test_hash_enabled<std::hash<Type>, Type>(); }
+    static void apply() { test_hash_enabled<ala::hash<Type>, Type>(); }
 };
 
 template <class Types>
diff --git a/test/support/test_macros.h b/test/support/test_macros.h
index bd08ddf..ed6cd03 100644
--- a/test/support/test_macros.h
+++ b/test/support/test_macros.h
@@ -14,10 +14,10 @@
 // minimal header possible. If we're testing libc++, we should use `<__config>`.
 // If <__config> isn't available, fall back to <ciso646>.
 #ifdef __has_include
-# if __has_include("<__config>")
-#   include <__config>
-#   define TEST_IMP_INCLUDED_HEADER
-# endif
+// # if __has_include("<__config>")
+// #   include <__config>
+// #   define TEST_IMP_INCLUDED_HEADER
+// # endif
 #endif
 #ifndef TEST_IMP_INCLUDED_HEADER
 #include <ciso646>
@@ -236,7 +236,8 @@
 #endif
 
 /* Macros for testing libc++ specific behavior and extensions */
-#if defined(_LIBCPP_VERSION)
+// ala
+#if defined(_LIBCPP_VERSION) && !defined(_ALA_VERSION)
 #define LIBCPP_ASSERT(...) assert(__VA_ARGS__)
 #define LIBCPP_STATIC_ASSERT(...) static_assert(__VA_ARGS__)
 #define LIBCPP_ASSERT_NOEXCEPT(...) ASSERT_NOEXCEPT(__VA_ARGS__)
@@ -248,9 +249,10 @@
 #define LIBCPP_ASSERT_NOEXCEPT(...) ((void)0)
 #define LIBCPP_ASSERT_NOT_NOEXCEPT(...) ((void)0)
 #define LIBCPP_ONLY(...) ((void)0)
+#undef _LIBCPP_VERSION
 #endif
 
-#if !defined(_LIBCPP_HAS_NO_RANGES)
+#if !defined(_LIBCPP_HAS_NO_RANGES) && !defined(_ALA_VERSION)
 #define TEST_SUPPORTS_RANGES
 #endif
 
diff --git a/test/support/variant_test_helpers.h b/test/support/variant_test_helpers.h
index 92faf79..de89356 100644
--- a/test/support/variant_test_helpers.h
+++ b/test/support/variant_test_helpers.h
@@ -12,6 +12,7 @@
 #include <type_traits>
 #include <utility>
 #include <cassert>
+#include <ala/variant.h>
 
 #include "test_macros.h"
 #include "type_id.h"
@@ -76,7 +77,7 @@ int MakeEmptyT::alive = 0;
 
 template <class Variant>
 void makeEmpty(Variant& v) {
-    Variant v2(std::in_place_type<MakeEmptyT>);
+    Variant v2(ala::in_place_type<MakeEmptyT>);
     try {
         v = std::move(v2);
         assert(false);
